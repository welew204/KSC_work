from django.test import TestCase

from django.contrib.auth.models import User
from .models import Tweet


class CreatingNewUserTestCase(TestCase):
    def test_shows_homepage_text(self):
        # Quick check to make sure the text "Yell about" exists on the
        # homepage, since it should no matter what
        response = self.client.get('/')
        self.assertContains(response, 'Yell about')

    def test_homepage_shows_all_tweets_link(self):
        response = self.client.get('/')
        self.assertContains(response, 'All Tweets')
        # Also check for "all-tweets/" to ensure the link is correctly
        # rendered.
        self.assertContains(response, 'all-tweets/')

    def test_shows_form(self):
        # Let's make sure that the homepage shows the expected form. To do so,
        # we just "spot check" for a few different expected bits of text.
        response = self.client.get('/')
        self.assertContains(response, 'Username:')
        self.assertContains(response, 'First name:')
        self.assertContains(response, 'Last name:')
        html = '<input type="text" name="username"'
        self.assertContains(response, html)

    def test_submit_creates_new_user(self):
        # First make sure we don't have any users
        user_count = User.objects.count()
        self.assertEqual(user_count, 0)

        # Now we simulate the post request generated by
        # the form
        self.client.post('/', {
            'username': 'testuser',
            'first_name': 'Test',
            'last_name': 'User',
            'password': 'testpass',
            'email': 'testuser@fake.com',
        })

        # Then, we check that a new user was created
        user_count = User.objects.count()
        self.assertEqual(user_count, 1)

        # ...and we check that the user has the
        # properties we entered into the form
        user = User.objects.get(username='testuser')
        self.assertEqual(user.username, 'testuser')
        self.assertEqual(user.first_name, 'Test')
        self.assertEqual(user.last_name, 'User')
        self.assertEqual(user.email, 'testuser@fake.com')



class TweetListsAppearTestCase(TestCase):
    def setUp(self):
        fake_user = User.objects.create(username='test')
        Tweet.objects.create(
            user=fake_user,
            text="This is a testing tweet",
        )

    def test_all_tweets_page_shows_a_tweet(self):
        response = self.client.get('/all-tweets/')
        self.assertContains(response, "This is a testing tweet")
        self.assertContains(response, "@test")


    def test_user_page_shows_tweet(self):
        response = self.client.get('/users/test/')
        self.assertContains(response, "This is a testing tweet")
        self.assertContains(response, "@test")






class CreateTweetFormTestCase(TestCase):
    def setUp(self):
        # Get a fake user created and logged in
        fake_user = User.objects.create(username='test')
        fake_user.set_password('1234')
        fake_user.save()
        self.client.login(username='test', password='1234')

    def test_does_not_show_user_until_tweeted(self):
        response = self.client.get('/all-tweets/')
        # the @test user should not be on all-tweets
        self.assertNotContains(response, "@test")

    def test_shows_form_to_tweet(self):
        # Let's make sure that the homepage shows the expected form. To do so,
        # we just "spot check" for a few different expected bits of HTML.
        response = self.client.get('/users/test/')
        html = '<input type="text" name="text"'
        self.assertContains(response, html)
        html = '<button class="btn btn-lg btn-info">Tweet</button>'
        self.assertContains(response, html)

    def test_tweet_form_works(self):
        # Now we simulate the post request generated by
        # the form
        self.client.post('/users/test/', {
            'text': 'This is a testing tweet',
        })

        # Ensure the tweet appears in all-tweets
        response = self.client.get('/all-tweets/')
        self.assertContains(response, "This is a testing tweet")
        self.assertContains(response, "@test")

        # Ensure the tweet appears in the user's page
        response = self.client.get('/users/test/')
        self.assertContains(response, "This is a testing tweet")
        self.assertContains(response, "@test")


class UpdateTweetTestCase(TestCase):
    def setUp(self):
        # Get a fake user created and logged in
        fake_user = User.objects.create(username='test')
        fake_user.set_password('1234')
        fake_user.save()
        self.client.login(username='test', password='1234')
        tweet = Tweet.objects.create(
            user=fake_user,
            text="This is a testing tweet",
        )
        self.tweet_id = tweet.id

    def test_does_not_show_user_until_tweeted(self):
        # Ensure the tweet appears in all-tweets
        response = self.client.get('/all-tweets/')
        self.assertContains(response, "This is a testing tweet")
        self.assertContains(response, "@test")

        # Now we simulate the post request generated by
        # the form
        self.client.post('/update-tweet/%i/' % self.tweet_id, {
            'text': 'brand new test',
        })

        # Ensure the edited tweet appears in all-tweets
        response = self.client.get('/all-tweets/')
        self.assertNotContains(response, "This is a testing tweet")
        self.assertContains(response, "brand new test")
        self.assertContains(response, "@test")

        # Ensure the edited tweet appears in the user's page
        response = self.client.get('/users/test/')
        self.assertNotContains(response, "This is a testing tweet")
        self.assertContains(response, "brand new test")
        self.assertContains(response, "@test")



class LikingTweetTestCase(TestCase):
    def setUp(self):
        # Create a fake user and log in
        fake_user = User.objects.create(username='test')
        fake_user.set_password('1234')
        fake_user.save()
        self.client.login(username='test', password='1234')
        tweet = Tweet.objects.create(
            user=fake_user,
            text="This is a testing tweet",
        )
        self.tweet_id = tweet.id

    def test_liking_tweets_increases_like_count(self):
        response = self.client.get('/all-tweets/')

        # Make sure it starts with 0 likes
        html = '<i class="octicon octicon-heart"></i>0'
        self.assertContains(response, html)

        # Now we simulate the GET request generated by
        # clicking the "like tweet" link
        self.client.get('/like-tweet/%i/' % self.tweet_id)

        # Now make sure that it shows 1 like
        response = self.client.get('/all-tweets/')
        html = '<i class="octicon octicon-heart"></i>1'
        self.assertContains(response, html)


    def test_liking_tweets_twice_does_not_increase_like_count(self):
        response = self.client.get('/all-tweets/')

        # Make sure it starts with 0 likes
        html = '<i class="octicon octicon-heart"></i>0'
        self.assertContains(response, html)

        # Now we simulate the GET request generated by
        # clicking the "like tweet" link
        self.client.get('/like-tweet/%i/' % self.tweet_id)

        # Now make sure that it shows 1 like
        response = self.client.get('/all-tweets/')
        html = '<i class="octicon octicon-heart"></i>1'
        self.assertContains(response, html)

        # Simulate another like tweet get
        self.client.get('/like-tweet/%i/' % self.tweet_id)

        # Ensure the number didn't change
        response = self.client.get('/all-tweets/')
        html = '<i class="octicon octicon-heart"></i>1'
        self.assertContains(response, html)



