This activity is different: Instead of using SQL directly, or developing a
Python project, we'll be getting practice with the ORM related tools that come
with Django, showing more advanced usage of the ORM and how it relates to SQL.

- We'll use again the "The Book Club" project. This time, however, you can't
  run "runserver". This activity is all about the database.




Challenge 1: Installation & test script
------------------------------------------

1. Installation: Time to get everything ready to go! As this is based on the
Project Starter, generally, it requires three steps:

        pipenv --python 3
        pipenv shell
        pipenv install --skip-lock --dev      # might cause ignorable error


2. It's a little trickier to get practice with how SQL is generated by Models
in Django. For your convenience, a helper script is included. Try it out, from
within a virtual environment:

        bash wipe_and_show_schema.sh

3. If all went well, you should see a message similar to the following:


        ------------------------------------------
        -- SQL                                  --
        ------------------------------------------
        BEGIN;
        -- (...snip.... lots of CREATE TABLE etc goes here........)
        COMMIT;



- Warning: This helper script deletes migrations! This can mess up your
  database, so don't run this script in any project that matters.




Challenge 2: Django `db_index` and `unique`
-----------------------------------------------

- Background: Django models support easily adding database indexes. This speeds
  up WHERE look-ups on that field, sorting by that field, and more. However,
  each index you add can reduce the speed of INSERTs, so in real-life, only add
  to fields where you need it!
- SQL concepts: `CREATE INDEX` and `UNIQUE`
- Documentation: <https://docs.djangoproject.com/en/3.1/topics/db/models/>


Goal: For this challenge, practice "turning on" the index feature on Django
fields, by adding `db_index=True,` to their field definition.

1. Try adding an index to "title", by modifying the ReadingList title field so
that it looks like this (found in apps/core/models.py):

        title = models.CharField(
            max_length=100,
            db_index=True,
        )

2. Once you have done that, try running the `bash wipe_and_show_schema.sh`
script. It will spit out the SQL code required to make your edited model.

3. Once you have confirmed that SQL was generated that mentions an index on the
"title" field, try adding indices to other fields, and confirm you see it in
the re-generated SQL.

4. Also try the same thing with `unique=True,`. This prevents duplicate entries
to show up on that field.


Comprehension questions:

1. What happens in the generated SQL when you add an index to a field?
2. Which field(s) automatically got indices, without you having to add one?
3. What are uses of `unique=True`?




Challenge 3: Django constraints
--------------------------------------

- Background: Django models support easily adding database constraints. This
  causes the database to enforce flexible sets of rules on data that enters it.

Goal: Instead of making Books titles "universally unique" with `unique=True`,
let's make them unique _within_ a ReadingList. In other words, while its okay
for more than one ReadingList to have the same book (or at least a book with
the same title), we don't want the same book to be added twice to an individual
reading list.

1. Add a special "Meta" class to the top of the Book model as such:

        class Book(models.Model):
            class Meta:
                unique_together = [
                    ['title', 'reading_list'],
                ]
            # Rest of Book remaints the same...

2. Once you have done that, try running the `bash wipe_and_show_schema.sh`
script. It will spit out the SQL code required to make your edited model.

3. Optional: Try again, with Django 3's new more flexible (but also more
verbose and confusing) constraint syntax. In addition to the unique title, this
example also requires that Books start with the word 'The':


        class Book(models.Model):
            class Meta:
                constraints = [
                    models.UniqueConstraint(
                        fields=['title', 'reading_list'],
                        name="unique_title_in_list",
                    ),
                    models.CheckConstraint(
                        check=models.Q(title__startswith='The'),
                        name='books_must_start_with_the',
                    ),
                ]
            # Rest of Book remaints the same...










Challenge #4: QuerySet `select_related`
--------------------------------------

- Background: Django QuerySets can use `select_related` and a special double
  syntax to pull in data from two models at once, allowing for more efficient
  database queries that "grab everything in one trip".

- Corresponding SQL: `JOIN`

In order to this challenge, you'll need to "fix" the test database, and then
start up a shell. Run the following in a virtualenv:

        bash reset_db_test_data.sh
        python manage.py shell

If you get errors, try restoring the models.py to how it was originally.

Then, continue with the following activities:


1. Run this code example in the `manage.py shell`. Observe how a INNER JOIN was
generated in the SQL in each example:

```python

from apps.core.models import ReadingList, Book

# double underscore: Using JOIN to filter
qs = Book.objects.filter(reading_list__category='fiction')
print(qs)
print(qs.query)

# select_related: Using JOIN to bring in data from multiple tables
qs = Book.objects.all().select_related('reading_list')
print(qs)
print(qs.query)

first_book = qs[0]
print(first_book.reading_list.title)

```

2. This `select_related` code gets all the information from the `reading_list`
that corresponds to each book at the same time as getting information on the
books themselves.  In other words, it gets data from both the ReadingList and
Book tables.

3. Try running this code again, but omitting the
`.select_related('reading_list')` from the initial Query, as such:


```python

from apps.core.models import ReadingList, Book

qs = Book.objects.all()
print(qs)
print(qs.query)

first_book = qs[0]
print(first_book.reading_list.title)

```


4. It still works. But look closely: No JOIN was generated by the first query!

5. Comprehension Question:
    - "How is this possible!?!?!"

    - Answer: When you do `first_book.reading_list`, it does ANOTHER query to
      the database to get the extra info. This works great in a pinch, but can
      be very inefficient if it happens too much, generating too many queries.
      That's why `select_related` exists, to prevent extra queries.


